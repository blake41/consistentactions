---
layout: post
title: "the road ahead"
date: 2012-12-11 09:31
comments: true
categories:
published: false
---

I've spent the past 3+ months trying to figure out what I was looking for in my next job.  I've tried to talk with as many programmers I consider to be "good" to get a sense of how they got where they are.  I've talked with my Hacker School facilitators/mentors (and no disrepect) but even that hasn't truly yielded a concrete sense of how one becomes a great programmer.  Becoming a great program is my singular goal.  I've always believed that if you pursue excellence in everything you do, the rest will take care of itself.  Expose yourself to great people, ask for help, help others get where they want to go, speak up for yourself, and then bring your unique set of talents to the table.  That is the general recipe I've always followed.  For as long as I can remember I've been pretty certain about everything.  Most people would look at my past choices and think I was nuts, or lost, but I never felt crazy, and I always knew where I was going and what I wanted.  <!--more--> Ever since I read the four hour work week I've also been obsessed with challenging norms, and figuring out how to live the life I wanted by doing the 20% that was delivering 80% of the value.  Unfortunately, the path to becoming a great developer has been more like a drunk kid wandering through the Fireswamp.  What are the critical things one needs to learn?  What are the best ways of learning them?  Should I be watching videos?  Should I be reading code? Should I be writing my own gems?  If programming skill was rated on a scale of 1-10, if you're at a 4 what projects do you need to take on to get to level 5?  Should I learn a new programming language?  How well do I need to know Ruby?  How will I know when I've mastered Ruby?  How do I get better at design patterns?  Is there a body of knowledge you need to master to be a great developer?

The best answers to these questions usually are vague and to the tune of well, it depends.  The worst answers to these questions are non answers, or cases where the person honestly hasn't reflected about how they got to where they are.  So rather than continue to complain about the lack of answers to these questions, I'm going to try and articulate my answers to as well as I can at this point.

If you're starting from 0 and want to become a programmer, the most important thing you can do is do it 24/7.  Learning to program closesly parallels learning a language.  You must immerse yourself in it.  1 hour a day for seven days != 7 hours on one day once a week.  The former is much better in my opinion.  I find that when you only do it once a week, you forget everything you learned the previous week and start roughly from 0 each time you pick it back up.  Even better would be 3 hours a week for 3 times a week because it takes some time to get into the zone so you lose something by doing short bursts often.  The only real way to get good enough to get a job (in a reasonable amount of time < 1 year) is to quit your job and do it 16 hours a day for 3 months.  I'm not quite sure why it takes 3 months, but that's about the amount of time it took me to get a job once I quit my job.  It also happens to be the amount of time all the rails boot camps run for, so there's got to be something to that amount of time.  Additionally, I think the amount of progress you can make with a dedicated teacher/group is orders of magnitude more than you can grow on your own.  When you're by yourself, your rate of growth is x, which is often restricted by stupid mistakes a more experienced programmer could correct in minutes rather than the hours or days you might get stuck on something stupid.  With a teacher you learn at x + y with y being the teachers ability to explain new concepts faster than you'd grasp them on your own.  If you add a group setting I think it's something like X + y + z.  Z being some intangible measure of social pressure, the boost to your natural momentum you get from the groups motivation and an environment where everyone is focused on one thing.  If the Flatiron School existed 2 years ago when I started this journey I would have done it without a thought.  I think Avi's students grew more in 3 months than I probably did in 6.  One of the keys to this 3 months is to learn a valuable skill.  I think becoming a jack of all trades and master of none is the best way to ensure that you are unhirable for a long time.  It's extremely important to go deeper in all the computer science topics that make people great programmers.  However, for your first job, there's a lot of programming busywork available to anyone who has a basic grasp of a web development framework.  Once you get good enough to be able to handle that, then you can program all day every day and get paid to continue to grow your skillset.  You're not going to become a master chef overnight, but if you can learn to cook a good omelette you can get a job as an omelette maker and learn how to cook everything else once you get there.

The world constantly complains about the dearth of competent, good, and great programmers.  Yet it seems few people have thought about what it takes to go from competent to good to great.  Two examples of leadership in this area worth mentioning are Thoughtbot's apprenticeship program and Obtiva's (now Groupon) apprenticeship program. (http://redsquirrel.com/cgi-bin/dave/obtiva/apprenticeship.program.first.year.html, http://www.thoughtbot.com/jobs/apprentice)  Both of these companies seem to have put a lot of thought into how you become great.  Thoughtbot in particular offers courses to grow developers which are taught by their own developers.  They use Fridays to work on their internal tools which they then use to build better software for their customers.  Talk about eating your own dogfood.  

Another area worth exploring is how companies allocate work.  At any company there are bugs, infrastructure demands, maintenance/changes to the existing codebase, and new initiatives.  How do you allocate those tasks among your developers?  Which projects are the best projects to work on as a developer who wants to grow.  Here's where things get a little fuzzy for me but I'm going to take my best shot at this one.  You're much better off joining a smaller company who is writing a substantial amount of new code rather than a larger company with a larger more established codebase.  When you join a large established codebase you spend most of your time making modifications to existing design.  The amount of time you spend doing much actual high level thinking as far as design/architecture is effectively 0 as things are so solidified that if you wanted to change the design of somethign for your simple feature you'd have to rewrite a substantial part of the existing application.  Given you have 3 days to do your feature this is not an option.  So you never have time to do any original thinking.  You never get pushed to make your own architectural decisions, or even have those conversations as to what good design is.  You don't really see how things could be designed better.  All you see is the current state of things and as a junior person you're unlikely to even have ideas about how it could be different, it just IS.  Working in a substantially new codebase forces you to create new things forcing you to do design even if you aren't doing it at a fully cognitive level.  Making bad design choices is better for growth than not making any decisions.  How can you learn what bad design is unless you design something poorly first (even if it's just on a whiteboard) and seeing the flaws of the system you created.  I think my ideal situation is being forced to design new things, and then having a review with someone more senior to get their input into the flaws in my system, and then rearchitecting things to the point that those considerations have been worked out and then sitting down to code up the solution.  

Is it better to consult on short term projects or work on one project for an extended period of time?  My guess is that at the start working on many projects in short bursts is the best way to get exposure to a lot of different ideas/problems and solutions.  If you're stuck on one thing you might only learn the problems of one domain.  If you're moving fast even if you get stuck on a project where you're learning very little, you will get a chance to move on shortly.  That said, you're probably never going to get to great in this way as you never work on something long enough to really see the results of your architectural decisions.  There's really nothing (I imagine) like working on a platform at the scale of facebook or twitter.  The things that work for a million users just won't work for 100 million.  So maybe you start by banging out a bunch of short projects and then move onto a larger platform as you master the smaller domain problems?