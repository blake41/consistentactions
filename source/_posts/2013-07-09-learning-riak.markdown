---
layout: post
title: "learning riak"
published: false
date: 2013-07-09 10:15
comments: true
categories: 
---

The Flatiron School just started a new program where we can get any programming book we want so I've decided to take full advantage.  While I was in Ocean City over the long weekend I wanted to explore the world of "NoSQL."  My general sense with this whole world was that 95% of use cases still made sense to use a RDBMS but that as long as Mongo was hip, Mongo was what people would want to blindly use.  So I wanted to answer the question for myself, if your data is relational, does it make sense to use Mongo?  I'd also read a lot of horror stories with Mongo and was curious to see if I could understand them myself.  This whole line of inquiry eventually led me to the CAP theorem and Riak.  Around 2000 Eric Brewer came out with his paper/conjecture called the CAP Theorem [Brewer Paper](http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf).  The CAP Theorem was eventually proved and started a lot of the discussions around NoSQL.  CAP Theroem essentially says that in any distributed system you can't have consistency, availability and Partition tolerance all at the same time.  Pick two out of those three.  Consistency means that if you have many nodes with the same data, and you read data from more than 1 at once, you should get the exact same result.  Availability means that I should be able to read from all nodes at all times.  Partition tolerance means that if nodes are physically separated from each other, usually by network problems, they should still be able to serve both reads and writes.  So the theorem really states that since we assume that all computers will have network problems and be partitioned from the rest of the nodes at SOME point, you HAVE to pick P as one of the two of three in CAP you are allowed.  So then the question really is, do you compromise your availability or consistency.  

A simple example: 
Suppose you have three nodes all with the same data.  You go to write data to all three, but one node is unreachable.  You then go to read data, you might get stale data from the node that missed the write earlier.  If the system allows you to read from the stale node before it's been synced up the system has chosen availability of data as its focus.  If it won't give you the data until everything has been synced up, it's chosen consistency and sacrificed availability.  So either you can get all data all of the time, and some of it might be wrong, or you get can all of the data most of the time and it's always right.  According to the book, many developers of systems claim that their systems have chosen to be AC systems.  This shows a fundamental misunderstanding of CAP, let alone physics.  All systems will face network partitions or a node going down at some point, so you MUST choose P and one of C or A.

So what does Riak choose?  The cool thing about Riak is that it let's you decide.  Riak was based on a paper which came out of Amazon in 2007 about Dynamo DB, amazon's internal "eventually consistent" database.  Project Voldemort and CouchDB are also based on this idea of eventual consistency.  Riak alows you to tune your needs of consistency and availability.  Interally each group within Amazon has different business cases for whether they would prefer to have their data be always available and possibly wrong, or always correct and sometimes unavailable.  Let's say you have a system with 5 nodes, you can specify that for any write to be successful it has to be written to W nodes.  The higher W value you pick the higher your consistency but the higher probability that a write might fail due to a node being unreachable.  As you lower W your data becomes more likely to successfully write but has a high probability of being inconsistent as you might read data from a node that hadn't been updated.  A higher W will also affect speed as the more nodes that must be written to will increase the network latency.

For reads, the logic is similar.  If you need to read consistent data from R nodes for a read to be successful you increase your consistency but also increase the probability that a node is unreachable or has to wait for an update.  As you lower your R the probability a read is successful increases but is more likely to have inconsistent data.  As you tune both R and W towards N you are lowering your ability to tolerate P (partitions).  If R and W are 100% you no longer can tolerate any partition.

The most common scenario in real world applications is that a write will reach all the relevant nodes eventually, so that all nodes have the same data. Eventually the data in the whole cluster will be consistent for this particular piece of data, no matter how long it takes, even after network partitions. This is where the term eventual consistency comes from.

## Does Riak replace traditional RDBMS's?

In a word, no.  Riak is really cool, and I'm excited to play with it, but it solves a very different use case than the traditional SQL databases.  There's not really a focus in the Riak data model on objects that relate to each other.  You can use linking to relate object, but there's not really any way to query Riak in the way most web developers are used to.  You can use map reduce to replicate that functionality, but you'd have to write ad hoc map reduce statements every time you needed data which is not really what it's for.  Map Reduce is really for batch processing of data, not real time application access to the database.  You can also add Lucene to Riak to do full text search of data, but again this is not really what we want.  The simplest example of why Riak doesn't cut it is there's really no notion of a collection of Objects.  Riak has buckets, but this is really just a string key they add to your actual key.  You can't ask Riak for all the things in X bucket.  It still has to sort through every key in the db to see if it matches the string "X".  For the same reason you can't count all the objects in a bucket.  Riak does have the notion of relationships through "linking" but this really works more like a graph db does than traditional relationships as we think of them in the SQL world.  The best way to think of Riak is a key-value store on steroids that deals really well with distributed storage, replication, fails gracefully and allows you to tune the AC part of CAP to your hearts content.
